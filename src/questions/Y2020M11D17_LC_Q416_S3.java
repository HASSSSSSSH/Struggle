package questions;

/**
 * https://leetcode-cn.com/problems/partition-equal-subset-sum/
 * 给定一个 只包含正整数 的 非空 数组, 是否可以将这个数组分割成 两个子集, 使得两个子集的元素和相等
 * <p>
 * 注意:
 * 每个数组中的元素不会超过 100
 * 数组的大小不会超过 200
 * <p>
 * 示例 1:
 * 输入: [1, 5, 11, 5]
 * 输出: true
 * 解释: 数组可以分割成 [1, 5, 5] 和 [11]
 * <p>
 * 示例 2:
 * 输入: [1, 2, 3, 5]
 * 输出: false
 * 解释: 数组不能分割成两个元素和相等的子集
 * <p>
 * Solution: Dynamic Programming
 * <p>
 * 时间复杂度: O(n * target), n 是数组的长度, target 是整个数组的元素和的一半
 * <p>
 * 空间复杂度: O(target), target 是整个数组的元素和的一半
 * <p>
 * Optimization of {@link Y2020M11D17_LC_Q416_S2}
 */
public class Y2020M11D17_LC_Q416_S3 {

    public static void main(String args[]) {
        Y2020M11D17_LC_Q416_S3 instance = new Y2020M11D17_LC_Q416_S3();

        // new int[]{1, 5, 11, 5}
        // new int[]{1, 2, 3, 5}
        // new int[]{9, 5}
        // new int[]{100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 99, 97}

        System.out.println(instance.canPartition(new int[]{1, 5, 11, 5}));
    }

    /**
     * 优化空间
     * <p>
     * 事实上, 在 dp[i][j] 的计算过程中
     * 只参考上一行 dp[i - 1][j'], j' ∈ [0, j] 的结果
     * 因此可以使用滚动数组, 只记录两行结果
     */
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        int length = nums.length;

        // 当数组元素少于 2 个 或者 数组总数值不是 2 的倍数时
        // 无法满足数组分割成两个子集, 使得两个子集的元素和相等
        // ((sum & 1) != 0) same as (sum % 2 != 0)
        if (length < 2 || (sum & 1) != 0) {
            return false;
        }

        int half = sum >> 1;

        boolean[][] dp = new boolean[2][half + 1];

        // 初始化数组第一列, 使得状态方程成立
        // 事实上只需要初始化数组第一行的第一列
        // 因为在接下来的遍历中, 目标数值 j 是从 0 开始的, 使得状态方程总是成立
        dp[0][0] = true;

        // 单独考虑第 1 个元素, 初始化数组的第一行
        // 需要满足 nums[0] <= half, 否则会出现数组越界
        if (nums[0] <= half) {
            dp[0][nums[0]] = true;
        }

        for (int i = 1; i < length; i++) {
            // j 必须从 0 开始
            // 因为有可能在不选择 nums[i] 的情况下, 数组的子区间 [0, i - 1] 能够 恰好 凑成目标数值 j
            for (int j = 0; j <= half; j++) {
                dp[i & 1][j] = dp[(i - 1) & 1][j];

                if (j >= nums[i] && dp[(i - 1) & 1][j - nums[i]]) {
                    dp[i & 1][j] = true;
                }
            }
        }

        // 不可能出现选择了所有元素才能满足 总数值 = half 的情况
        // 因为 sum ≠ sum / 2 (sum % 2 == 0)
        return dp[(length - 1) & 1][half];
    }
}
