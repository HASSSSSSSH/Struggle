package questions;

/**
 * https://leetcode-cn.com/problems/partition-equal-subset-sum/
 * 给定一个 只包含正整数 的 非空 数组, 是否可以将这个数组分割成 两个子集, 使得两个子集的元素和相等
 * <p>
 * 注意:
 * 每个数组中的元素不会超过 100
 * 数组的大小不会超过 200
 * <p>
 * 示例 1:
 * 输入: [1, 5, 11, 5]
 * 输出: true
 * 解释: 数组可以分割成 [1, 5, 5] 和 [11]
 * <p>
 * 示例 2:
 * 输入: [1, 2, 3, 5]
 * 输出: false
 * 解释: 数组不能分割成两个元素和相等的子集
 * <p>
 * Solution: Dynamic Programming
 * <p>
 * 时间复杂度: O(n * target), n 是数组的长度, target 是整个数组的元素和的一半
 * <p>
 * 空间复杂度: O(n * target), n 是数组的长度, target 是整个数组的元素和的一半
 */
public class Y2020M11D17_LC_Q416_S2 {

    public static void main(String args[]) {
        Y2020M11D17_LC_Q416_S2 instance = new Y2020M11D17_LC_Q416_S2();

        // new int[]{1, 5, 11, 5}
        // new int[]{1, 2, 3, 5}
        // new int[]{9, 5}
        // new int[]{100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 99, 97}

        System.out.println(instance.canPartition(new int[]{1, 5, 11, 5}));
    }

    /**
     * 动态规划
     * <p>
     * 1.定义状态
     * dp[i][j]: 候选数组的前缀子区间 [0, i] 是否能够 恰好 凑成目标数值 j
     * <p>
     * 2.状态转移方程
     * 遍历数组, 考虑是否将遍历到的数字加入到 "组合" 中
     * <p>
     * 如果考虑将遍历到的数字 nums[i] 加入到 "组合" 中, 此时需要确认候选数组的子区间 [0, i - 1] 是否能够 恰好 凑成目标数值 j - nums[i]
     * 所以 dp[i][j] = dp[i - 1][j - nums[i]] (j >= nums[i])
     * <p>
     * 如果不考虑将遍历到的数字 nums[i] 加入到 "组合" 中, 此时需要确认候选数组的子区间 [0, i - 1] 是否能够 恰好 凑成目标数值 j
     * 所以 dp[i][j] = dp[i - 1][j]
     * <p>
     * 综上所述, 可以得出状态转移方程:
     * dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]] (j >= nums[i])
     * <p>
     * 3.思考初始化
     * 当遍历到的数字 nums[i] 恰好等于 目标数值 j 时, 说明候选数组在前缀子区间 [0, i] 能够 恰好 凑成目标数值 j
     * 所以 dp[i][j] = dp[i - 1][j - nums[i]] = dp[i - 1][0] = true 总是成立
     * <p>
     * 因此需要初始化 dp 数组的第一列, dp[i][0] = true, 其中 0 <= i < length
     * <p>
     * 同时, 还需要单独考虑候选数组的第 1 个元素, 初始化数组的第一行
     * 当 nums[0] <= half 时, 有 dp[0][nums[0]] = true, 其中 half 为 1/2 的数组总数值
     * <p>
     * 4.思考输出
     * 输出的结果应该是: 候选数组在区间 [0, length - 1] 是否能够 恰好 凑成数值 half, 其中 half 为 1/2 的数组总数值
     * 如果能够 恰好 凑成数值 half, 那么说明: 数组能够分割成两个子集, 使得两个子集的元素和相等
     * 因此输出应为: dp[length - 1][half]
     */
    public boolean canPartition(int[] nums) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        int length = nums.length;

        // 当数组元素少于 2 个 或者 数组总数值不是 2 的倍数时
        // 无法满足数组分割成两个子集, 使得两个子集的元素和相等
        // ((sum & 1) != 0) same as (sum % 2 != 0)
        if (length < 2 || (sum & 1) != 0) {
            return false;
        }

        // 数字右移一位 相当于 数值除2
        int half = sum >> 1;

        boolean[][] dp = new boolean[length][half + 1];

        // 初始化数组第一列, 使得状态方程成立
        // 事实上只需要初始化数组第一行的第一列
        // 因为在接下来的遍历中, 目标数值 j 是从 0 开始的, 使得状态方程总是成立
        dp[0][0] = true;
        // for (int i = 0; i < length; i++) {
        //     dp[i][0] = true;
        // }

        // 单独考虑第 1 个元素, 初始化数组的第一行
        // 需要满足 nums[0] <= half, 否则会出现数组越界
        if (nums[0] <= half) {
            dp[0][nums[0]] = true;
        }

        for (int i = 1; i < length; i++) {
            // j 必须从 0 开始
            // 因为有可能在不选择 nums[i] 的情况下, 数组的子区间 [0, i - 1] 能够 恰好 凑成目标数值 j
            for (int j = 0; j <= half; j++) {
                dp[i][j] = dp[i - 1][j];

                if (j >= nums[i] && dp[i - 1][j - nums[i]]) {
                    dp[i][j] = true;
                }
            }
        }

        // 不可能出现选择了所有元素才能满足 总数值 = half 的情况
        // 因为 sum ≠ sum / 2 (sum % 2 == 0)
        return dp[length - 1][half];
    }
}
