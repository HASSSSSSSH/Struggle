package questions;

/**
 * https://leetcode-cn.com/problems/partition-equal-subset-sum/
 * 给定一个 只包含正整数 的 非空 数组, 是否可以将这个数组分割成 两个子集, 使得两个子集的元素和相等
 * <p>
 * 注意:
 * 每个数组中的元素不会超过 100
 * 数组的大小不会超过 200
 * <p>
 * 示例 1:
 * 输入: [1, 5, 11, 5]
 * 输出: true
 * 解释: 数组可以分割成 [1, 5, 5] 和 [11]
 * <p>
 * 示例 2:
 * 输入: [1, 2, 3, 5]
 * 输出: false
 * 解释: 数组不能分割成两个元素和相等的子集
 * <p>
 * Solution: Depth First Search & Backtrack
 * <p>
 * 时间复杂度: ??
 * <p>
 * 空间复杂度: ??
 * <p>
 * Result: Time Limit Exceeded
 */
public class Y2020M11D17_LC_Q416_S1 {

    public static void main(String args[]) {
        Y2020M11D17_LC_Q416_S1 instance = new Y2020M11D17_LC_Q416_S1();

        // new int[]{1, 5, 11, 5}
        // new int[]{1, 2, 3, 5}
        // new int[]{9, 5}
        // new int[]{100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,
        //         100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 99, 97}

        System.out.println(instance.canPartition(new int[]{1, 5, 11, 5}));
    }

    public boolean canPartition(int[] nums) {
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        return sum % 2 == 0 && dfs(0, nums, 0, sum >> 1);
    }

    public boolean dfs(int begin, int[] nums, int total, int target) {
        if (total == target) {
            return true;
        }
        if (total > target) {
            return false;
        }
        for (int i = begin; i < nums.length; i++) {
            if (dfs(i + 1, nums, total + nums[i], target)) {
                return true;
            }
        }
        return false;
    }
}
